#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "../include/cpu.h"
#include "../include/inst.h"
#include "../include/bus.h"

void pushInternal(MW1000* cpu, DWORD data) {
	cpu->sp -= 4;
	BusWrite(cpu->sp + 1, data << 24 >> 24);
	BusWrite(cpu->sp + 2, data << 16 >> 24);
	BusWrite(cpu->sp + 3, data << 8 >> 24);
	BusWrite(cpu->sp + 4, data >> 24);
}

DWORD popInternal(MW1000* cpu) {
	char b1 = BusRead(cpu->sp + 1);
	char b2 = BusRead(cpu->sp + 2);
	char b3 = BusRead(cpu->sp + 3);
	char b4 = BusRead(cpu->sp + 4);
	cpu->sp += 4;
	return b1 + (b2 >> 8) + (b3 >> 16) + (b4 >> 24);
}

bool HasPermission(MW1000* cpu, DWORD addr) {
	for (char i = 0; i < 4; i++) {
		if (cpu->permTables[i].permLevel < cpu->permission)
			if (cpu->permTables[i].start < cpu->pc && cpu->pc < cpu->permTables[i].start + cpu->permTables[i].size)
				return false;
	}

	return true;
}

DWORD FloatToInt(float f) {
	return *((DWORD*) (&f));
}

float IntToFloat(DWORD i) {
	return *((float*) (&i));
}

bool RunInstruction(MW1000* cpu) {
	MW1000* temp = malloc(sizeof(MW1000));
	BYTE inst = BusRead(cpu->pc);
	cpu->pc++;
	if (inst > 64)
		return false;
	memcpy(temp, cpu, sizeof(MW1000));
	if (!instructions[inst](cpu)) {
		memcpy(cpu, temp, sizeof(MW1000));
		return false;
	}
	free(temp);
	return true;
}

MW1000* CreateMW1000(Bus* bus) {
	MW1000* result = malloc(sizeof(MW1000));
	//result->memory = malloc(memSize);
	//result->memSize = memSize;
	//result->romSize = romSize;
	result->pc = 0;
	result->sp = 0;
	result->permission = 0;
	result->status.cFlag = 0;
	result->status.zFlag = 0;
	result->status.oFlag = 0;
	result->status.iFlag = 0;
    result->status.dFlag = 0;
	result->status.sFlag = 0;
    result->status.pFlag = 0;
	for (int i = 0; i < 16; i++) {
		result->permTables[i].start = 0;
		result->permTables[i].size = 0;
		result->permTables[i].permLevel = 0;
		result->gpio[i] = 0;
		result->gpregs[i] = 0;
	}
	return result;
}

void DestroyMW1000(MW1000* cpu)
{
    free(cpu);
}
