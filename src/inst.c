#include <math.h>

#include "../include/cpu.h"

//----------------------\\
// Control Instructions \\
//----------------------\\

bool HLT(MW1000* cpu) {
	cpu->pc--;
	return true;
}

bool INTR(MW1000* cpu) {
	cpu->iFlag = true;
	return true;
}

bool RET(MW1000* cpu) {
	cpu->pc = popInternal(cpu);
	return true;
}

bool IRET(MW1000* cpu) {
	cpu->pc = popInternal(cpu);
	DWORD p = popInternal(cpu);
	if (p > 15)
		return false;
	cpu->permission = (char) p;
	return true;
}

bool JMP(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc = cpu->registers[reg];
	return true;
}

bool JPZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) == 0)
		cpu->pc = cpu->registers[regAddr];
	return true;
}

bool JNZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) != 0)
		cpu->pc = cpu->registers[regAddr];
	return true;
}

bool JCZ(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->cFlag == 0)
		cpu->pc = cpu->registers[reg];
	return true;
}

bool JNCZ(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->cFlag != 0)
		cpu->pc = cpu->registers[reg];
	return true;
}

bool CALL(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	pushInternal(cpu, cpu->pc + 1);
	if (reg > 15)
		return false;
	cpu->pc = cpu->registers[reg];
	return true;
}

bool CLZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) == 0) {
		cpu->pc = cpu->registers[regAddr];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CNZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) != 0) {
		cpu->pc = cpu->registers[regAddr];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CPC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->cFlag == 0) {
		cpu->pc = cpu->registers[reg];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CNC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->cFlag == 0) {
		cpu->pc = cpu->registers[reg];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool STP(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15 || cpu->registers[reg] > 7)
		return false;
	if (cpu->registers[reg] > cpu->permission)
		cpu->permission = cpu->registers[reg];
	return true;
}

//---------------------\\
// Memory Instructions \\
//---------------------\\

bool MRC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	char b1 = ReadMemory(cpu, cpu->pc + 1);
	char b2 = ReadMemory(cpu, cpu->pc + 2);
	char b3 = ReadMemory(cpu, cpu->pc + 3);
	char b4 = ReadMemory(cpu, cpu->pc + 4);
	cpu->registers[reg] = b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);
	return true;
}

bool MRR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg2];
	return true;
}

bool MRM(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ReadMemory(cpu, cpu->registers[reg2]);
	return true;
}

bool MMR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	WriteMemory(cpu, cpu->registers[reg1], cpu->registers[reg2]);
	return true;
}
bool IN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc) >> 4;
	char port = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg] = cpu->io[port];
	return true;
}

bool OUT(MW1000* cpu) {
	char port = ReadMemory(cpu, cpu->pc) >> 4;
	char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->io[port] = cpu->registers[reg];
	return true;
}

bool STTS(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		cpu->permTables[table].start = cpu->registers[reg];
	}
	return true;
}

bool STTL(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		cpu->permTables[table].size = cpu->registers[reg];
	}
	return true;
}

bool STTP(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		if (cpu->registers[reg] > 7)
			return false;
		cpu->permTables[table].permLevel = cpu->registers[reg];
	}
	return true;
}

//------------------\\
// ALU Instructions \\
//------------------\\

bool ADD(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] += cpu->registers[reg2];
	return true;
}

bool SUB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] -= cpu->registers[reg2];
	return true;
}

bool ADDC(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] += cpu->registers[reg2];
	cpu->cFlag = (char) (((long long) cpu->registers[reg1] + (long long) cpu->registers[reg2]) >> 32);
	return true;
}

bool SUBB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] -= cpu->registers[reg2];
	cpu->cFlag = (char) !((bool) (((2 ^ 32) + (long long) cpu->registers[reg1] - (long long) cpu->registers[reg2]) >> 32));
	return true;
}

bool MUL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] *= cpu->registers[reg2];
	return true;
}
bool DIV(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] /= cpu->registers[reg2];
	return true;
}

bool POW(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = (DWORD) pow(cpu->registers[reg1], cpu->registers[reg2]);
	return true;
}

bool SHL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] <<= cpu->registers[reg2];
	return true;
}

bool SHR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] >>= cpu->registers[reg2];
	return true;
}

bool ROTL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->registers[reg1] >> (32 - cpu->registers[reg2]);
	cpu->registers[reg1] << cpu->registers[reg2];
	cpu->registers[reg1] += carry;
	return true;
}

bool ROTR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->registers[reg1] << (32 - cpu->registers[reg2]);
	cpu->registers[reg1] >> cpu->registers[reg2];
	cpu->registers[reg1] += carry;
	return true;
}

bool INC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	cpu->registers[reg]++;
	return true;
}

bool DEC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	cpu->registers[reg]--;
	return true;
}

bool AND(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] & cpu->registers[reg2];
	return true;
}

bool OR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] | cpu->registers[reg2];
	return true;
}

bool NOT(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->registers[reg] = ~(cpu->registers[reg]);
	return true;
}

bool XOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] ^ cpu->registers[reg2];
	return true;
}

bool XNOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] ^ cpu->registers[reg2]);
	return true;
}

bool NAND(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] & cpu->registers[reg2]);
	return true;
}

bool NOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] | cpu->registers[reg2]);
	return true;
}

bool COMP(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] == cpu->registers[reg2];
	return true;
}

bool LESS(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] < cpu->registers[reg2];
	return true;
}

bool MORE(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] < cpu->registers[reg2];
	return true;
}

//------------------\\
// FPU Instructions \\
//------------------\\

bool FPADD(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) + IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
	return true;
}

bool FPSUB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) - IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
	return true;
}

bool FPMUL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) * IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
	return true;
}

bool FPDIV(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) / IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
	return true;
}

bool FPINC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg]) + 1;
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPDEC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg]) - 1;
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPNEG(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = -IntToFloat(cpu->registers[reg]);
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPSIN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = sin(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPCOS(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = cos(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPTAN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = tan(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPASIN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = asin(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPACOS(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = acos(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPATAN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = atan(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool SPSQRT(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = sqrt(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPLOG(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = log(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
	return true;
}

bool FPPOW(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = pow(IntToFloat(cpu->registers[reg1]), IntToFloat(cpu->registers[reg2]));
	cpu->registers[reg1] = FloatToInt(temp);
	return true;
}

bool CONVIF(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	cpu->registers[reg] = FloatToInt((float) cpu->registers[reg]);
	return true;
}

bool CONVFI(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	cpu->registers[reg] = (DWORD) IntToFloat(cpu->registers[reg]);
	return true;
}