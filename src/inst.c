#include <math.h>
#include "../include/cpu.h"
#include "../include/bus.h"

//----------------------\\
// Control Instructions \\
//----------------------\\

bool HLT(MW1000* cpu) {
    if(!cpu->interrupt)
    {
        cpu->pc--;   
    }
	return true;
}

bool INTR(MW1000* cpu) {
	cpu->status.iFlag = true;
	return true;
}

bool RET(MW1000* cpu) {
	cpu->pc = popInternal(cpu);
	return true;
}

bool IRET(MW1000* cpu) {
	if (cpu->permission == 0) {
		cpu->pc = popInternal(cpu);
		DWORD p = popInternal(cpu);
		if (p > 15)
			return false;
		cpu->permission = (char)p;
	}
	return true;
}

bool JMP_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc = cpu->gpregs[reg];
	return true;
}

bool JPZ_REG(MW1000* cpu) {
	char regAddr = BusRead(cpu->pc) >> 4;
	char regCond = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->gpregs[regCond] << 31 >> 31) == 0)
		cpu->pc = cpu->gpregs[regAddr];
	return true;
}

bool JNZ_REG(MW1000* cpu) {
	char regAddr = BusRead(cpu->pc) >> 4;
	char regCond = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->gpregs[regCond] << 31 >> 31) != 0)
		cpu->pc = cpu->gpregs[regAddr];
	return true;
}

bool JNC_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->status.cFlag == 0)
		cpu->pc = cpu->gpregs[reg];
	return true;
}

bool JC_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->status.cFlag != 0)
		cpu->pc = cpu->gpregs[reg];
	return true;
}

bool CALL_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	pushInternal(cpu, cpu->pc + 1);
	if (reg > 15)
		return false;
	cpu->pc = cpu->gpregs[reg];
	return true;
}

bool CALLZ_REG(MW1000* cpu) {
	char regAddr = BusRead(cpu->pc) >> 4;
	char regCond = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->gpregs[regCond] << 31 >> 31) == 0) {
		cpu->pc = cpu->gpregs[regAddr];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CALLNZ_REG(MW1000* cpu) {
	char regAddr = BusRead(cpu->pc) >> 4;
	char regCond = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->gpregs[regCond] << 31 >> 31) != 0) {
		cpu->pc = cpu->gpregs[regAddr];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CALLC_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->status.cFlag == 0) {
		cpu->pc = cpu->gpregs[reg];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

bool CALLNC_REG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	if (cpu->status.cFlag == 0) {
		cpu->pc = cpu->gpregs[reg];
		pushInternal(cpu, cpu->pc);
	}
	return true;
}

//---------------------\\
// Memory Instructions \\
//---------------------\\

bool MOV_REG_IMM(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	char b1 = BusRead(cpu->pc + 1);
	char b2 = BusRead(cpu->pc + 2);
	char b3 = BusRead(cpu->pc + 3);
	char b4 = BusRead(cpu->pc + 4);
	cpu->gpregs[reg] = b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);
	return true;
}

bool MOV_REG_REG(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = cpu->gpregs[reg2];
	return true;
}

bool MOV_REG_MEM(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = BusRead(cpu->gpregs[reg2]);
	return true;
}

bool MOV_MEM_REG(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	BusWrite(cpu->gpregs[reg1], cpu->gpregs[reg2]);
	return true;
}
bool IN(MW1000* cpu) {
	char reg = BusRead(cpu->pc) >> 4;
	char port = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg] = cpu->gpio[port];
	return true;
}

bool OUT(MW1000* cpu) {
	char port = BusRead(cpu->pc) >> 4;
	char reg = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpio[port] = cpu->gpregs[reg];
	return true;
}

//------------------\\
// ALU Instructions \\
//------------------\\

bool ADD(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] += cpu->gpregs[reg2];
	return true;
}

bool SUB(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] -= cpu->gpregs[reg2];
	return true;
}

bool ADDC(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] += cpu->gpregs[reg2];
	cpu->status.cFlag = (char) (((long long) cpu->gpregs[reg1] + (long long) cpu->gpregs[reg2]) >> 32);
	return true;
}

bool SUBB(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] -= cpu->gpregs[reg2];
	cpu->status.cFlag = (char) !((bool) (((2 ^ 32) + (long long) cpu->gpregs[reg1] - (long long) cpu->gpregs[reg2]) >> 32));
	return true;
}

bool MUL(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] *= cpu->gpregs[reg2];
	return true;
}
bool DIV(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] /= cpu->gpregs[reg2];
	return true;
}

bool POW(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = (DWORD) pow(cpu->gpregs[reg1], cpu->gpregs[reg2]);
	return true;
}

bool SHL(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] <<= cpu->gpregs[reg2];
	return true;
}

bool SHR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] >>= cpu->gpregs[reg2];
	return true;
}

bool ROTL(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->gpregs[reg1] >> (32 - cpu->gpregs[reg2]);
	cpu->gpregs[reg1] << cpu->gpregs[reg2];
	cpu->gpregs[reg1] += carry;
	return true;
}

bool ROTR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->gpregs[reg1] << (32 - cpu->gpregs[reg2]);
	cpu->gpregs[reg1] >> cpu->gpregs[reg2];
	cpu->gpregs[reg1] += carry;
	return true;
}

bool INC(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	cpu->gpregs[reg]++;
	return true;
}

bool DEC(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	cpu->pc++;
	if (reg > 15)
		return false;
	cpu->gpregs[reg]--;
	return true;
}

bool AND(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = cpu->gpregs[reg1] & cpu->gpregs[reg2];
	return true;
}

bool OR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = cpu->gpregs[reg1] | cpu->gpregs[reg2];
	return true;
}

bool NOT(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->gpregs[reg] = ~(cpu->gpregs[reg]);
	return true;
}

bool XOR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = cpu->gpregs[reg1] ^ cpu->gpregs[reg2];
	return true;
}

bool XNOR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = ~(cpu->gpregs[reg1] ^ cpu->gpregs[reg2]);
	return true;
}

bool NAND(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = ~(cpu->gpregs[reg1] & cpu->gpregs[reg2]);
	return true;
}

bool NOR(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = ~(cpu->gpregs[reg1] | cpu->gpregs[reg2]);
	return true;
}

bool COMP(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->gpregs[reg1] = cpu->gpregs[reg1] == cpu->gpregs[reg2];
	return true;
}

//------------------\\
// FPU Instructions \\
//------------------\\

bool FPADD(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg1]) + IntToFloat(cpu->gpregs[reg2]);
	cpu->gpregs[reg1] = FloatToInt(temp);
	return true;
}

bool FPSUB(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg1]) - IntToFloat(cpu->gpregs[reg2]);
	cpu->gpregs[reg1] = FloatToInt(temp);
	return true;
}

bool FPMUL(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg1]) * IntToFloat(cpu->gpregs[reg2]);
	cpu->gpregs[reg1] = FloatToInt(temp);
	return true;
}

bool FPDIV(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg1]) / IntToFloat(cpu->gpregs[reg2]);
	cpu->gpregs[reg1] = FloatToInt(temp);
	return true;
}

bool FPINC(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg]) + 1;
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPDEC(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = IntToFloat(cpu->gpregs[reg]) - 1;
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPNEG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = -IntToFloat(cpu->gpregs[reg]);
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPSIN(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = sin(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPCOS(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = cos(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPTAN(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = tan(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPASIN(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = asin(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPACOS(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = acos(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPATAN(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = atan(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool SPSQRT(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = sqrt(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPLOG(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	float temp = log(IntToFloat(cpu->gpregs[reg]));
	cpu->gpregs[reg] = FloatToInt(temp);
	return true;
}

bool FPPOW(MW1000* cpu) {
	char reg1 = BusRead(cpu->pc) >> 4;
	char reg2 = BusRead(cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = pow(IntToFloat(cpu->gpregs[reg1]), IntToFloat(cpu->gpregs[reg2]));
	cpu->gpregs[reg1] = FloatToInt(temp);
	return true;
}

bool CONVIF(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	cpu->gpregs[reg] = FloatToInt((float) cpu->gpregs[reg]);
	return true;
}

bool CONVFI(MW1000* cpu) {
	char reg = BusRead(cpu->pc);
	if (reg > 15)
		return false;
	cpu->pc++;
	cpu->gpregs[reg] = (DWORD) IntToFloat(cpu->gpregs[reg]);
	return true;
}
