#include <math.h>

#include "../include/cpu.h"

//----------------------\\
// Control Instructions \\
//----------------------\\

void HLT(MW1000* cpu) {
	cpu->pc--;
}

void INTR(MW1000* cpu) {
	cpu->iFlag = true;
}

void RET(MW1000* cpu) {
	cpu->pc = popInternal(cpu);
}

void IRET(MW1000* cpu) {
	cpu->pc = popInternal(cpu);
	DWORD p = popInternal(cpu);
	if (p > 15) {
		error = true;
		return;
	}
	cpu->permission = (char) p;
}

void JMP(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc = cpu->registers[reg];
}

void JPZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) == 0)
		cpu->pc = cpu->registers[regAddr];
}

void JNZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) != 0)
		cpu->pc = cpu->registers[regAddr];
}

void JCZ(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	if (cpu->cFlag == 0)
		cpu->pc = cpu->registers[reg];
}

void JNCZ(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	if (cpu->cFlag != 0)
		cpu->pc = cpu->registers[reg];
}

void CALL(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	pushInternal(cpu, cpu->pc + 1);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc = cpu->registers[reg];
}

void CLZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) == 0) {
		cpu->pc = cpu->registers[regAddr];
		pushInternal(cpu, cpu->pc);
	}
}

void CNZ(MW1000* cpu) {
	char regAddr = ReadMemory(cpu, cpu->pc) >> 4;
	char regCond = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	if ((cpu->registers[regCond] << 31 >> 31) != 0) {
		cpu->pc = cpu->registers[regAddr];
		pushInternal(cpu, cpu->pc);
	}
}

void CPC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	if (cpu->cFlag == 0) {
		cpu->pc = cpu->registers[reg];
		pushInternal(cpu, cpu->pc);
	}
}

void CNC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	if (cpu->cFlag == 0) {
		cpu->pc = cpu->registers[reg];
		pushInternal(cpu, cpu->pc);
	}
}

void STP(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15 || cpu->registers[reg] > 7) {
		error = true;
		return;
	}
	if (cpu->registers[reg] > cpu->permission)
		cpu->permission = cpu->registers[reg];
}

//---------------------\\
// Memory Instructions \\
//---------------------\\

void MRC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	char b1 = ReadMemory(cpu, cpu->pc + 1);
	char b2 = ReadMemory(cpu, cpu->pc + 2);
	char b3 = ReadMemory(cpu, cpu->pc + 3);
	char b4 = ReadMemory(cpu, cpu->pc + 4);
	cpu->registers[reg] = b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);
}

void MRR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg2];
}

void MRM(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ReadMemory(cpu, cpu->registers[reg2]);
}

void MMR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	WriteMemory(cpu, cpu->registers[reg1], cpu->registers[reg2]);
}
void IN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc) >> 4;
	char port = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg] = cpu->io[port];
}

void OUT(MW1000* cpu) {
	char port = ReadMemory(cpu, cpu->pc) >> 4;
	char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->io[port] = cpu->registers[reg];
}

void STTS(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		cpu->permTables[table].start = cpu->registers[reg];
	}
}

void STTL(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		cpu->permTables[table].size = cpu->registers[reg];
	}
}

void STTP(MW1000* cpu) {
	if (cpu->permission == 0) {
		char table = ReadMemory(cpu, cpu->pc) >> 4;
		char reg = ReadMemory(cpu, cpu->pc) << 4 >> 4;
		cpu->pc++;
		if (cpu->registers[reg] > 7)
			error = true;
		cpu->permTables[table].permLevel = cpu->registers[reg];
	}
}

//------------------\\
// ALU Instructions \\
//------------------\\

void ADD(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] += cpu->registers[reg2];
}

void SUB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] -= cpu->registers[reg2];
}

void ADDC(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] += cpu->registers[reg2];
	cpu->cFlag = (char) (((long long) cpu->registers[reg1] + (long long) cpu->registers[reg2]) >> 32);
}

void SUBB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] -= cpu->registers[reg2];
	cpu->cFlag = (char) !((bool) (((2 ^ 32) + (long long) cpu->registers[reg1] - (long long) cpu->registers[reg2]) >> 32));
}

void MUL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] *= cpu->registers[reg2];
}
void DIV(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] /= cpu->registers[reg2];
}

void POW(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = (DWORD) pow(cpu->registers[reg1], cpu->registers[reg2]);
}

void SHL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] <<= cpu->registers[reg2];
}

void SHR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] >>= cpu->registers[reg2];
}

void ROTL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->registers[reg1] >> (32 - cpu->registers[reg2]);
	cpu->registers[reg1] << cpu->registers[reg2];
	cpu->registers[reg1] += carry;
}

void ROTR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	char carry = cpu->registers[reg1] << (32 - cpu->registers[reg2]);
	cpu->registers[reg1] >> cpu->registers[reg2];
	cpu->registers[reg1] += carry;
}

void INC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->registers[reg]++;
}

void DEC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	cpu->pc++;
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->registers[reg]--;
}

void AND(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] & cpu->registers[reg2];
}

void OR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] | cpu->registers[reg2];
}

void NOT(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->registers[reg] = ~(cpu->registers[reg]);
}

void XOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] ^ cpu->registers[reg2];
}

void XNOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] ^ cpu->registers[reg2]);
}

void NAND(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] & cpu->registers[reg2]);
}

void NOR(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = ~(cpu->registers[reg1] | cpu->registers[reg2]);
}

void COMP(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] == cpu->registers[reg2];
}

void LESS(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] < cpu->registers[reg2];
}

void MORE(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	cpu->registers[reg1] = cpu->registers[reg1] < cpu->registers[reg2];
}

//------------------\\
// FPU Instructions \\
//------------------\\

void FPADD(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) + IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
}

void FPSUB(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) - IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
}

void FPMUL(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) * IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
}

void FPDIV(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg1]) / IntToFloat(cpu->registers[reg2]);
	cpu->registers[reg1] = FloatToInt(temp);
}

void FPINC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg]) + 1;
	cpu->registers[reg] = FloatToInt(temp);
}

void FPDEC(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = IntToFloat(cpu->registers[reg]) - 1;
	cpu->registers[reg] = FloatToInt(temp);
}

void FPNEG(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = -IntToFloat(cpu->registers[reg]);
	cpu->registers[reg] = FloatToInt(temp);
}

void FPSIN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = sin(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPCOS(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = cos(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPTAN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = tan(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPASIN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = asin(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPACOS(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = acos(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPATAN(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = atan(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void SPSQRT(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = sqrt(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPLOG(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	float temp = log(IntToFloat(cpu->registers[reg]));
	cpu->registers[reg] = FloatToInt(temp);
}

void FPPOW(MW1000* cpu) {
	char reg1 = ReadMemory(cpu, cpu->pc) >> 4;
	char reg2 = ReadMemory(cpu, cpu->pc) << 4 >> 4;
	cpu->pc++;
	float temp = pow(IntToFloat(cpu->registers[reg1]), IntToFloat(cpu->registers[reg2]));
	cpu->registers[reg1] = FloatToInt(temp);
}

void CONVIF(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	cpu->registers[reg] = FloatToInt((float) cpu->registers[reg]);
}

void CONVFI(MW1000* cpu) {
	char reg = ReadMemory(cpu, cpu->pc);
	if (reg > 15) {
		error = true;
		return;
	}
	cpu->pc++;
	cpu->registers[reg] = (DWORD) IntToFloat(cpu->registers[reg]);
}